import { Component, NgZone, OnChanges, Input, ElementRef, Output, EventEmitter, ViewChild, ChangeDetectorRef, ContentChild, TemplateRef, ContentChildren, Directive, QueryList } from '@angular/core';
import { ContentChildrenDecorator, Query } from '@angular/core/src/metadata/di';
import { Treetable } from './treetable/treetable';

@Directive({
	selector: "list-cell",
})
export class ListCellComponent {
	@Input() name;
	@Input() prop;
	@Input() useTemplate;
	@Input() headerTemplate;
	@Input() width;
	@Input() css;
	@Input() invisiable;
	@ContentChild(TemplateRef) template: QueryList<any>;
}

@Component({
	selector: "list",
	templateUrl: './list.html',
	styleUrls: ["./list.scss"],
})
export class ListComponent {
	constructor(
		private cdr: ChangeDetectorRef,
	) { }
	// treetable 树形列表
	private treetableInstance = new Treetable;
	private _treetable = false;
	@Input() set treetable(isTreetable) {
		if (typeof isTreetable == "string") {
			this._treetable = true;
		} else {
			this._treetable = isTreetable;
		}
	}
	get treetable() {
		return this._treetable;
	}
	@Input() manual: boolean = false;
	@ViewChild("datetime") set datetime(template) {
		this.innerTemplates.datetime = template;
	}
	@ViewChild("treetableTmp") set treetableTmp(template) {
		this.innerTemplates.treetableTmp = template;
	}
	/**
	 * 内置模板
	 */
	innerTemplates = {
		datetime: {},
		treetableTmp: {},
	}
	/**
	 * 读取行模板
	 */
	@ContentChildren(TemplateRef) contentTemplates;
	@ContentChildren(ListCellComponent) listCellTep;
	_cellTemplates;
	@ContentChildren(ListCellComponent) set cellTemplates(templates: ListCellComponent[]) {
		this._cellTemplates = templates;
		let headers = [];
		templates.map(item => {
			if (typeof item.useTemplate == "string") {
				item.useTemplate = this.innerTemplates[item.useTemplate];
			}
			if (!item.useTemplate) {
				if (item.template) {
					item.useTemplate = item.template;
				}
			}
			headers.push(item)
		})
		if (this.treetable) {
			headers.unshift({
				useTemplate: this.innerTemplates.treetableTmp,
				width: 40,
				css: "text-left",
			})
		}
		if (headers.length) {
			this.headers = headers;
		}
	};
	get cellTemplates() {
		return this._cellTemplates;
	}
	@Input() flat;
	@Input() templates = {};
	tableWidth: number = 0;
	@Input() list;
	_totalSize;
	@Input() set totalSize(totalSize) {
		this._totalSize = totalSize;
		this.pageTotalIndex = Math.ceil(totalSize / (this.pageSize || 1))
	};
	get totalSize() {
		return this._totalSize;
	}
	_pageSize = 10
	@Input() set pageSize(pageSize) {
		this._pageSize = pageSize;
		this.pageTotalIndex = Math.ceil((this.totalSize || 0) / this.pageSize)
	};
	get pageSize() {
		return this._pageSize;
	}
	pageIndex: number = 1;
	pageTotalIndex: number = 40;
	@ViewChild("container") container: ElementRef;
	_headers;
	@Input() set headers(values) {
		if (!values) {
			return;
		}
		if (typeof values == "string") {
			let valuesArr = values.split(",");
			let headers = valuesArr.map(item => {
				return {
					name: item,
					prop: item,
				}
			})
			this._headers = headers;
		} else {
			values.map(item => {
				if (typeof item.useTemplate == "string") {
					item.useTemplate = this.innerTemplates[item.useTemplate];
				}
				item.oriWidth = item.width;
			})
			let _values = [];
			values.map(item => {
				if (item.invisiable) {
					return
				}
				_values.push(item);
			})
			this._headers = _values;
		}
		this.calcHeaders(this._headers);
	};
	get headers() {
		return this._headers;
	}
	calcHeaders(headers) {
		if (this.flat || !headers) {
			return;
		}
		let totalWidth = this.container.nativeElement.clientWidth - headers.length - 10;
		let expectWidth = 0;
		headers.map(item => {
			item.width = parseFloat(item.oriWidth) || 0;
			expectWidth += item.width;
		})
		let tableWidth = 0;
		if (expectWidth < totalWidth) {
			headers.map(item => {
				item.width = (parseInt((item.width / expectWidth) * 10000 as any) / 10000 * totalWidth) || (totalWidth / headers.length);
				tableWidth += item.width;
			})
		}
		this.tableWidth = tableWidth || expectWidth;
	}

	recalHeader() {
		this.cdr.detectChanges();
		setTimeout(() => {
			this.cellTemplates = this.listCellTep;
		}, 1)
	}

	@Output("onpage") onpage = new EventEmitter();

	refresh() {
		this.toPage(this.pageIndex);
	}
	loadingStatus: boolean;
	toPage(pageIndex) {
		if (this.loadingStatus) {
			return;
		}
		this.loadingStatus = true;
		pageIndex = parseInt(pageIndex);
		pageIndex - this.pageTotalIndex >= 0 && (pageIndex = this.pageTotalIndex);
		pageIndex <= 0 && (pageIndex = 1);
		let data: PageEvent = {} as any;
		data.isFirst = this.list ? false : true;
		data.pageSize = this.pageSize;
		data.pageIndex = pageIndex;
		data.complete = (e) => {
			this.loadingStatus = false;
			this.complete(e);
		};
		this.pageIndex = pageIndex;
		this.inputPageIndex = pageIndex;
		this.onpage.emit(data);
		// setTimeout(() => {
		// 	this.loadingStatus = false;
		// 	data.complete = () => { };
		// }, 5000)
	}
	complete(e: PageEvent) {
		if (this.pageIndex > 1) {
			if (e.list.length == 0) {
				return this.toPage(this.pageIndex - 1);
			}
		}
		this.totalSize = e.totalSize;
		// 树形列表
		if (this.treetable) {
			this.treetableInstance.calcDeep(e.list);
		}
		this.list = e.list;
		this.cdr.detectChanges();
	}
	inputPageIndex
	inputPageKeyUp(e) {
		if (e.keyCode == 13) {
			this.inputPageIndex = this.inputPageIndex || 1;
			let index = (+this.inputPageIndex);
			if (index == this.inputPageIndex) {
				this.toPage(this.inputPageIndex);
			} else {
				this.inputPageIndex = this.pageIndex;
			}
		}
	}
	resizeFn;
	ngOnInit() {
		window.addEventListener("resize", this.resizeFn = () => {
			this.calcHeaders(this._headers)
		})
		if (!this.manual) {
			this.toPage(1)
		}
	}

	ngOnDestroy() {
		window.removeEventListener("resize", this.resizeFn);
	}

}

export interface PageEvent {
	isFirst: boolean;
	pageIndex: number;
	pageSize: number;
	list: any[];
	totalSize: number;
	complete: (e: PageEvent) => void
}
