export class Treetable {

	calcDeep(item, deep: number = 0) {
		item.map((node, index) => {
			node.$$deep = deep + 1;
			node.$$same = item;
			node.$$index = index;
			node.$$expand = false;
			if (deep == 0) node.$$root = item;
			if (node.children) {
				node.children.map(child => {
					child.$$parent = item;
					if (deep == 0) child.$$root = item;
					else child.$$root = node.$$root;
				})
				this.calcDeep(node.children, deep + 1);
			}
		})
		return item;
	}

	calcDeepStyle(item) {
		let style = {
			'padding-left': `${item.$$deep * 10}px`,
		}
		return style;
	}

	findAllExpanded(item) {
		let data = [];
		if (item.$$expand && item.children) {
			data.push(item);
			item.children.map(node => {
				if (node.$$expand) {
					data = data.concat(this.findAllExpanded(node))
				}
			})
		}
		return data;
	}

	expand(item) {
		let parent = item.$$root;
		let index = item.$$index;
		if (item.children) {
			parent.some((node, i) => {
				if (node == item) {
					if (!item.$$expand) {
						let data = [i + 1, 0];
						item.children.map(childNode => data.push(childNode));
						parent.splice.apply(parent, data);
						item.$$expand = !item.$$expand;
					} else {
						let allExpand = this.findAllExpanded(item);
						allExpand.reverse();
						allExpand.map(item => {
							item.$$root.some((node, index) => {
								if (node == item) {
									item.$$root.splice(index + 1, node.children.length);
									item.$$expand = !item.$$expand;
									return true;
								}
							})
						})
					}
					return true;
				}
			})
		}
	}
}